'use strict';

const logger = require('loggy');

var fs = require('fs'),
    mkdir = require('mkdirp');

class LocalizationBrunch {
  constructor(config) {
    if (config == null) config = {};
    this.options = Object.assign({}, config.plugins && config.plugins.uglify || {});

    if (config.paths.root && config.paths.public) {
      this.path = config.paths.root + '/' + config.paths.public + /lang/;
    } else {
      this.path = 'public/lang/';
    }
  }

  compile(args) {
    let data,
        result, 
        lines,
        lineFeed,
        row, 
        i,
        j,
        translations,
        translation,
        transPath,
        colCount, 
        languages, 
        language,
        path,
        colValue,
        _this;

    data = args.data;

    try {
      if (data.indexOf("\r\n") > -1) {
        lineFeed = "\r\n";
      } else if (data.indexOf("\r") > -1) {
        lineFeed = "\r";
      } else {
        lineFeed = "\n";
      }

      lines = data.split(lineFeed);

      if (lines.length < 2) {
        return Promise.reject('nothing to translate');
      } 
      
      row = lines[0].split("\t")

      if (row.length < 3) {
        return Promise.reject('not enough rows');
      }

      colCount = row.length;

      translations = {};
      languages = [];

      for (i = 2; i < row.length; i++) {
        languages.push(row[i]);
        translations[row[i]] = {}
      }

      for (i = 1; i < lines.length; i ++) {
        row = lines[i].split("\t");

        if (row.length > 1) {
          if (row.length != colCount) {
            return Promise.reject('column count error at row ' + (i + 1) + "; expected:" + colCount + "; count: " + row.length);
          }

          for (j = 2; j < row.length; j++) {
            translation = translations[languages[j - 2]];

            transPath = row[0];

            if (transPath.length == 0) {
              return Promise.reject('translation path error at row ' + (i + 1));
            }

            if (!translation[transPath]) {
              translation[transPath] = {};
            }

            colValue = row[j];

            if (colValue.length > 2 && colValue[0] == '"' && colValue[colValue.length - 1] == '"') {
              colValue = colValue.substr(1, colValue.length - 2);
              colValue = colValue.replace(/\"\"/g, '"');
            }

            translation[transPath][row[1]] = colValue;
          }
        }
      }
    } catch (e) {
      return Promise.reject('error while compiling localization' + e);
    }

    _this = this;

    mkdir(_this.path, function(err) {
      for (i = 0; i < languages.length; i++) {
        language = languages[i];

        path = _this.path + language + '.json';

        logger.info('Writing localization for ' + language)

        fs.writeFile(path, JSON.stringify(translations[language]), 'utf8', function(err) {
          if (err) {
            return Promise.reject('error while writing localization file' + err);
          }

          logger.info('Localization file written.');
        });
      }
    });

    return Promise.resolve('');
  }
}

LocalizationBrunch.prototype.brunchPlugin = true;
LocalizationBrunch.prototype.type = 'localization';
LocalizationBrunch.prototype.extension = 'txt';
LocalizationBrunch.prototype.pattern = /languages\.txt$/;

module.exports = LocalizationBrunch;